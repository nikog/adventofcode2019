// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var $$Array = require("bs-platform/lib/js/array.js");
var $$String = require("bs-platform/lib/js/string.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

function parseOpcode(instruction) {
  var opcode = instruction % 10;
  var modes = (instruction - opcode | 0) / 100 | 0;
  return /* tuple */[
          opcode,
          Belt_Array.map(Belt_Array.reverse(String(modes).split("")), (function (code) {
                  var match = Caml_format.caml_int_of_string(code);
                  if (match !== 0 && match === 1) {
                    return /* Immediate */1;
                  } else {
                    return /* Position */0;
                  }
                }))
        ];
}

function getValue(instructions, modes, pointer, i) {
  var match = Belt_Array.get(modes, i - 1 | 0);
  if (match !== undefined && match) {
    return Caml_array.caml_array_get(instructions, pointer + i | 0);
  }
  return Caml_array.caml_array_get(instructions, Caml_array.caml_array_get(instructions, pointer + i | 0));
}

function loop(instructions, _pointer, input, _output) {
  while(true) {
    var output = _output;
    var pointer = _pointer;
    var withinBounds = pointer <= (instructions.length - 1 | 0);
    var match = parseOpcode(Caml_array.caml_array_get(instructions, pointer));
    var modes = match[1];
    var opcode = match[0];
    if (withinBounds && !(opcode >= 9 || opcode <= 0)) {
      switch (opcode - 1 | 0) {
        case 0 :
            var p1 = getValue(instructions, modes, pointer, 1);
            var p2 = getValue(instructions, modes, pointer, 2);
            var pos = Caml_array.caml_array_get(instructions, pointer + 3 | 0);
            Caml_array.caml_array_set(instructions, pos, p1 + p2 | 0);
            _pointer = pointer + 4 | 0;
            continue ;
        case 1 :
            var p1$1 = getValue(instructions, modes, pointer, 1);
            var p2$1 = getValue(instructions, modes, pointer, 2);
            var pos$1 = Caml_array.caml_array_get(instructions, pointer + 3 | 0);
            Caml_array.caml_array_set(instructions, pos$1, Caml_int32.imul(p1$1, p2$1));
            _pointer = pointer + 4 | 0;
            continue ;
        case 2 :
            var pos$2 = Caml_array.caml_array_get(instructions, pointer + 1 | 0);
            Caml_array.caml_array_set(instructions, pos$2, input);
            _pointer = pointer + 2 | 0;
            continue ;
        case 3 :
            var pos$3 = Caml_array.caml_array_get(instructions, pointer + 1 | 0);
            _output = $$Array.append(output, /* array */[Caml_array.caml_array_get(instructions, pos$3)]);
            _pointer = pointer + 2 | 0;
            continue ;
        case 4 :
            var jump = getValue(instructions, modes, pointer, 1) > 0;
            var newPointer = jump ? getValue(instructions, modes, pointer, 2) : pointer + 3 | 0;
            _pointer = newPointer;
            continue ;
        case 5 :
            var jump$1 = getValue(instructions, modes, pointer, 1) === 0;
            var newPointer$1 = jump$1 ? getValue(instructions, modes, pointer, 2) : pointer + 3 | 0;
            _pointer = newPointer$1;
            continue ;
        case 6 :
            var p1$2 = getValue(instructions, modes, pointer, 1);
            var p2$2 = getValue(instructions, modes, pointer, 2);
            var pos$4 = Caml_array.caml_array_get(instructions, pointer + 3 | 0);
            var match$1 = p1$2 < p2$2;
            Caml_array.caml_array_set(instructions, pos$4, match$1 ? 1 : 0);
            _pointer = pointer + 4 | 0;
            continue ;
        case 7 :
            var p1$3 = getValue(instructions, modes, pointer, 1);
            var p2$3 = getValue(instructions, modes, pointer, 2);
            var pos$5 = Caml_array.caml_array_get(instructions, pointer + 3 | 0);
            var match$2 = p1$3 === p2$3;
            Caml_array.caml_array_set(instructions, pos$5, match$2 ? 1 : 0);
            _pointer = pointer + 4 | 0;
            continue ;
        
      }
    } else {
      return /* tuple */[
              instructions,
              output
            ];
    }
  };
}

function make(instructions, input) {
  return loop(instructions, 0, input, /* array */[]);
}

var Part1 = {
  loop: loop,
  make: make
};

function readInput(param) {
  return Fs.readFileSync(__dirname + "/input", "utf8");
}

function solutionPart1(param) {
  var __x = Fs.readFileSync(__dirname + "/input", "utf8");
  var match = (function (param) {
        return make(param, 1);
      })($$Array.map(Caml_format.caml_int_of_string, $$Array.of_list($$String.split_on_char(/* "," */44, __x))));
  var output = match[1];
  return Caml_array.caml_array_get(output, output.length - 1 | 0);
}

console.log("day05 part1", solutionPart1(/* () */0));

function solutionPart2(param) {
  var __x = Fs.readFileSync(__dirname + "/input", "utf8");
  var match = (function (param) {
        return make(param, 5);
      })($$Array.map(Caml_format.caml_int_of_string, $$Array.of_list($$String.split_on_char(/* "," */44, __x))));
  var output = match[1];
  return Caml_array.caml_array_get(output, output.length - 1 | 0);
}

console.log("day05 part2", solutionPart2(/* () */0));

exports.parseOpcode = parseOpcode;
exports.getValue = getValue;
exports.Part1 = Part1;
exports.readInput = readInput;
exports.solutionPart1 = solutionPart1;
exports.solutionPart2 = solutionPart2;
/*  Not a pure module */
