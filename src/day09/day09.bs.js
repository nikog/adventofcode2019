// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var $$Array = require("bs-platform/lib/js/array.js");
var Int64 = require("bs-platform/lib/js/int64.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var Invalid_instruction = Caml_exceptions.create("Day09-Adventofcode2019.Invalid_instruction");

var Out_of_bounds = Caml_exceptions.create("Day09-Adventofcode2019.Out_of_bounds");

function parseOpcode(instruction) {
  var opcode = instruction % 100;
  var modes = (instruction - opcode | 0) / 100 | 0;
  return /* tuple */[
          opcode,
          Belt_Array.map(Belt_Array.reverse(String(modes).split("")), (function (code) {
                  var match = Caml_format.caml_int_of_string(code);
                  if (match > 2 || match < 0) {
                    return /* Position */0;
                  } else {
                    switch (match) {
                      case 0 : 
                          return /* Position */0;
                      case 1 : 
                          return /* Immediate */1;
                      case 2 : 
                          return /* Relative */2;
                      
                    }
                  }
                }))
        ];
}

function getIndex(instructions, modes, pointer, relativeBase, i) {
  var match = Belt_Array.get(modes, i - 1 | 0);
  if (match !== undefined) {
    switch (match) {
      case 0 : 
          return Caml_array.caml_array_get(instructions, pointer + i | 0)[1] | 0;
      case 1 : 
          return pointer + i | 0;
      case 2 : 
          return relativeBase + (Caml_array.caml_array_get(instructions, pointer + i | 0)[1] | 0) | 0;
      
    }
  } else {
    return Caml_array.caml_array_get(instructions, pointer + i | 0)[1] | 0;
  }
}

function loop(instructions, _pointer, input, _output, _relativeBase) {
  while(true) {
    var relativeBase = _relativeBase;
    var output = _output;
    var pointer = _pointer;
    var withinBounds = pointer <= (instructions.length - 1 | 0);
    var match = parseOpcode(Caml_array.caml_array_get(instructions, pointer)[1] | 0);
    var modes = match[1];
    var opcode = match[0];
    var basicGetIndex = (function(pointer,relativeBase,modes){
    return function basicGetIndex(param) {
      return getIndex(instructions, modes, pointer, relativeBase, param);
    }
    }(pointer,relativeBase,modes));
    if (withinBounds) {
      if (opcode >= 10) {
        if (opcode !== 99) {
          throw [
                Invalid_instruction,
                "Invalid instruction " + String(opcode)
              ];
        } else {
          return /* tuple */[
                  instructions,
                  output
                ];
        }
      } else if (opcode > 0) {
        switch (opcode - 1 | 0) {
          case 0 : 
              var p1 = Caml_array.caml_array_get(instructions, basicGetIndex(1));
              var p2 = Caml_array.caml_array_get(instructions, basicGetIndex(2));
              var pos = basicGetIndex(3);
              Caml_array.caml_array_set(instructions, pos, Caml_int64.add(p1, p2));
              _pointer = pointer + 4 | 0;
              continue ;
          case 1 : 
              var p1$1 = Caml_array.caml_array_get(instructions, basicGetIndex(1));
              var p2$1 = Caml_array.caml_array_get(instructions, basicGetIndex(2));
              var pos$1 = basicGetIndex(3);
              Caml_array.caml_array_set(instructions, pos$1, Caml_int64.mul(p1$1, p2$1));
              _pointer = pointer + 4 | 0;
              continue ;
          case 2 : 
              var pos$2 = basicGetIndex(1);
              Caml_array.caml_array_set(instructions, pos$2, input);
              _pointer = pointer + 2 | 0;
              continue ;
          case 3 : 
              var pos$3 = basicGetIndex(1);
              _output = $$Array.append(output, /* array */[Caml_array.caml_array_get(instructions, pos$3)]);
              _pointer = pointer + 2 | 0;
              continue ;
          case 4 : 
              var jump = (Caml_array.caml_array_get(instructions, basicGetIndex(1))[1] | 0) > 0;
              var newPointer = jump ? Caml_array.caml_array_get(instructions, basicGetIndex(2))[1] | 0 : pointer + 3 | 0;
              _pointer = newPointer;
              continue ;
          case 5 : 
              var jump$1 = (Caml_array.caml_array_get(instructions, basicGetIndex(1))[1] | 0) === 0;
              var newPointer$1 = jump$1 ? Caml_array.caml_array_get(instructions, basicGetIndex(2))[1] | 0 : pointer + 3 | 0;
              _pointer = newPointer$1;
              continue ;
          case 6 : 
              var p1$2 = Caml_array.caml_array_get(instructions, basicGetIndex(1));
              var p2$2 = Caml_array.caml_array_get(instructions, basicGetIndex(2));
              var pos$4 = basicGetIndex(3);
              var match$1 = Int64.compare(p1$2, p2$2) < 0;
              Caml_array.caml_array_set(instructions, pos$4, Caml_int64.of_int32(match$1 ? 1 : 0));
              _pointer = pointer + 4 | 0;
              continue ;
          case 7 : 
              var p1$3 = Caml_array.caml_array_get(instructions, basicGetIndex(1));
              var p2$3 = Caml_array.caml_array_get(instructions, basicGetIndex(2));
              var pos$5 = basicGetIndex(3);
              var match$2 = Int64.compare(p1$3, p2$3) === 0;
              Caml_array.caml_array_set(instructions, pos$5, Caml_int64.of_int32(match$2 ? 1 : 0));
              _pointer = pointer + 4 | 0;
              continue ;
          case 8 : 
              var p1$4 = Caml_array.caml_array_get(instructions, basicGetIndex(1))[1] | 0;
              _relativeBase = relativeBase + p1$4 | 0;
              _pointer = pointer + 2 | 0;
              continue ;
          
        }
      } else {
        throw [
              Invalid_instruction,
              "Invalid instruction " + String(opcode)
            ];
      }
    } else {
      throw [
            Out_of_bounds,
            "Out of bounds at " + String(pointer)
          ];
    }
  };
}

function make(instructions, input) {
  var memory = Caml_array.caml_make_vect(Caml_int32.imul(100, instructions.length), /* int64 */[
        /* hi */0,
        /* lo */0
      ]);
  var __x = $$Array.map(Caml_int64.of_int32, instructions);
  var instructionsWithMemory = $$Array.append(__x, memory);
  var match = loop(instructionsWithMemory, 0, Caml_int64.of_int32(input), /* array */[], 0);
  return /* tuple */[
          $$Array.map(Int64.to_string, match[0]),
          $$Array.map(Int64.to_string, match[1])
        ];
}

var Part1 = /* module */[
  /* loop */loop,
  /* make */make
];

function readInput() {
  return Fs.readFileSync(__dirname + "/input", "utf8");
}

function solutionPart1() {
  return (function (param) {
                return make(param, 1);
              })($$Array.map(Caml_format.caml_int_of_string, Fs.readFileSync(__dirname + "/input", "utf8").split((/,/))))[1];
}

console.log("day09 part1", solutionPart1(/* () */0));

function solutionPart1$1() {
  return (function (param) {
                return make(param, 2);
              })($$Array.map(Caml_format.caml_int_of_string, Fs.readFileSync(__dirname + "/input", "utf8").split((/,/))))[1];
}

console.log("day09 part2", solutionPart1$1(/* () */0));

exports.Invalid_instruction = Invalid_instruction;
exports.Out_of_bounds = Out_of_bounds;
exports.parseOpcode = parseOpcode;
exports.getIndex = getIndex;
exports.Part1 = Part1;
exports.readInput = readInput;
exports.solutionPart1 = solutionPart1$1;
/*  Not a pure module */
