// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

function coordinatesFromMap(map) {
  return $$Array.fold_left((function (param, param$1) {
                  var initialX = 0;
                  var param$2 = param;
                  var row = param$1;
                  var y = param$2[1];
                  var coords = $$Array.append(param$2[0], $$Array.fold_left((function (param, param$1) {
                                var y$1 = y;
                                var param$2 = param;
                                var i = param$1;
                                var x = param$2[1];
                                var acc = param$2[0];
                                var match = i === "#";
                                var coords = match ? $$Array.append(acc, /* array */[/* tuple */[
                                          x,
                                          y$1
                                        ]]) : acc;
                                return /* tuple */[
                                        coords,
                                        x + 1 | 0
                                      ];
                              }), /* tuple */[
                              /* array */[],
                              initialX
                            ], row.split(""))[0]);
                  return /* tuple */[
                          coords,
                          y + 1 | 0
                        ];
                }), /* tuple */[
                /* array */[],
                0
              ], map)[0];
}

function intTupleToFloat(param) {
  return /* tuple */[
          param[0],
          param[1]
        ];
}

function isBetween(coordA, coordB, coordC) {
  var match = intTupleToFloat(coordA);
  var a_y = match[1];
  var a_x = match[0];
  var match$1 = intTupleToFloat(coordB);
  var b_y = match$1[1];
  var b_x = match$1[0];
  var match$2 = intTupleToFloat(coordC);
  var c_y = match$2[1];
  var c_x = match$2[0];
  var crossproduct = (c_y - a_y) * (b_x - a_x) - (c_x - a_x) * (b_y - a_y);
  var dotproduct = (c_x - a_x) * (b_x - a_x) + (c_y - a_y) * (b_y - a_y);
  if (Math.abs(crossproduct) !== 0 || dotproduct < 0) {
    return false;
  } else {
    var squaredlengthba = (b_x - a_x) * (b_x - a_x) + (b_y - a_y) * (b_y - a_y);
    return dotproduct <= squaredlengthba;
  }
}

function sortCoordinates(center, a, b) {
  var match = intTupleToFloat(center);
  var c_y = match[1];
  var c_x = match[0];
  var match$1 = intTupleToFloat(a);
  var a_y = match$1[1];
  var a_x = match$1[0];
  var match$2 = intTupleToFloat(b);
  var b_x = match$2[0];
  if (a_x - c_x >= 0 && b_x - c_x < 0) {
    return 1;
  } else if (a_x - c_x < 0 && b_x - c_x >= 0) {
    return -1;
  } else {
    var b_y = match$2[1];
    if (a_x - c_x === 0 && b_x - c_x === 0) {
      if (a_y - c_y >= 0 || b_y - c_y >= 0) {
        var match$3 = a_y > b_y;
        if (match$3) {
          return 1;
        } else {
          return -1;
        }
      } else {
        var match$4 = b_y > a_y;
        if (match$4) {
          return 1;
        } else {
          return -1;
        }
      }
    } else {
      var det = (a_x - c_x) * (b_y - c_y) - (b_x - c_x) * (a_y - c_y);
      if (det < 0) {
        return 1;
      } else if (det > 0) {
        return -1;
      } else {
        var d1 = (a_x - c_x) * (a_x - c_x) + (a_y - c_y) * (a_y - c_y);
        var d2 = (b_x - c_x) * (b_x - c_x) + (b_y - c_y) * (b_y - c_y);
        var match$5 = d1 > d2;
        if (match$5) {
          return 1;
        } else {
          return -1;
        }
      }
    }
  }
}

function make(map) {
  var coordinates = coordinatesFromMap(map);
  var match = Belt_Array.reduce(coordinates, /* tuple */[
        /* tuple */[
          0,
          0
        ],
        0
      ], (function (param, coordA) {
          var visible = param[1];
          var visibleCoordinates = Belt_Array.keep(coordinates, (function (coordB) {
                  var match = Caml_obj.caml_equal(coordA, coordB);
                  if (match) {
                    return false;
                  } else {
                    return !Belt_Array.some(coordinates, (function (coordC) {
                                  var match = Caml_obj.caml_equal(coordC, coordB) || Caml_obj.caml_equal(coordC, coordA);
                                  if (match) {
                                    return false;
                                  } else {
                                    return isBetween(coordA, coordB, coordC);
                                  }
                                }));
                  }
                })).length;
          var match = visibleCoordinates > visible;
          if (match) {
            return /* tuple */[
                    coordA,
                    visibleCoordinates
                  ];
          } else {
            return /* tuple */[
                    param[0],
                    visible
                  ];
          }
        }));
  var match$1 = match[0];
  return /* tuple */[
          String(match$1[0]) + ("," + String(match$1[1])),
          match[1]
        ];
}

var Part1 = {
  make: make
};

function make$1(map) {
  var coordinates = coordinatesFromMap(map);
  var match = Belt_Array.reduce(coordinates, /* tuple */[
        /* tuple */[
          0,
          0
        ],
        0,
        /* array */[]
      ], (function (param, coordA) {
          var visible = param[1];
          var visibleCoordinates = Belt_Array.keep(coordinates, (function (coordB) {
                  var match = Caml_obj.caml_equal(coordA, coordB);
                  if (match) {
                    return false;
                  } else {
                    return !Belt_Array.some(coordinates, (function (coordC) {
                                  var match = Caml_obj.caml_equal(coordC, coordB) || Caml_obj.caml_equal(coordC, coordA);
                                  if (match) {
                                    return false;
                                  } else {
                                    return isBetween(coordA, coordB, coordC);
                                  }
                                }));
                  }
                }));
          var visibleCoordsCount = visibleCoordinates.length;
          var match = visibleCoordsCount > visible;
          if (match) {
            return /* tuple */[
                    coordA,
                    visibleCoordsCount,
                    visibleCoordinates
                  ];
          } else {
            return /* tuple */[
                    param[0],
                    visible,
                    param[2]
                  ];
          }
        }));
  var match$1 = match[0];
  var y = match$1[1];
  var transformed = $$Array.map((function (param) {
          return /* tuple */[
                  param[0] - y | 0,
                  Caml_int32.imul(param[1] - y | 0, -1)
                ];
        }), match[2]);
  var partial_arg_000 = match$1[0] - y | 0;
  var partial_arg_001 = y - y | 0;
  var partial_arg = /* tuple */[
    partial_arg_000,
    partial_arg_001
  ];
  $$Array.sort((function (param, param$1) {
          return sortCoordinates(partial_arg, param, param$1);
        }), transformed);
  return Belt_Array.reverse($$Array.map((function (param) {
                    return /* tuple */[
                            param[0] + y | 0,
                            Caml_int32.imul(param[1], -1) + y | 0
                          ];
                  }), transformed));
}

var Part2 = {
  make: make$1
};

exports.coordinatesFromMap = coordinatesFromMap;
exports.intTupleToFloat = intTupleToFloat;
exports.isBetween = isBetween;
exports.sortCoordinates = sortCoordinates;
exports.Part1 = Part1;
exports.Part2 = Part2;
/* No side effect */
